export default (cb, args) => {

    return (data) => {
        //обратная связь
        cb();
    }

}

//событие
// + новый путь, обработчик
// +


//получается что система воспроизводит события только для того, чтобы к ним можно было подключаться
//извне

/**
 * Оставить scheme
 * Сделать возможность эмитить события из разных источников, за счет определения текущих ttmp
 */


/**
 * кто добавит игру в схему?
 * при том что должен существовать модуль исходного кода для пакета, но он не может ссылаться на
 * готовую общую схему, так как она для него может разниться
 *
 * возможно достаточно особого пакета общего вида, который просто примет список существующих игр
 * и координаты для поиска
 *
 * здесь нужен пакет, который может работать (запрашивать загрузку) с компонентом списка
 */
import lucky from "lucky";

export default function (scheme, args) {

    scheme.games.use(lucky);

}


/**function (scheme, args) {
        lucky
    }
 * gs example
 *
 */

/**
 * схему можно модифицировать в старшем конфиге и пробрасывать только видоизмененные части
 * @param scheme
 * @param args
 */

import player from "player"

const source = {

    player: {
        player, //совпадающие с названием можно считать конструктором

        //например, пакет, который добавляет аккаунты
        accounts: {},

    },

    io: {
        item: [

        ],
        selected: {stream: 0xf},

    }

};

//преобразуется в

const out = {

    io: source.io,

};

/**
 * схема, это таже схема, которая попадет на вход в конструкторы
 */

export default function (scheme, args) {

    //здесь нужно как то собрать и объединить информацию со всех имеющихся игр

    //scheme.state.stream // - текущее состояние (возможно что нужно доставать из игр)
    //scheme.games.item.stream  // - текущие игры, поток, который порождает схемы,
    // из которых нужно доставать игры и которым нужно подписываться и отписываться

}



//так же нужна какая то опция, которая позволяет отложить сборку данного пакета
function some(scheme, args) {
    return {type: "delay"};
}
//возможность костылить или можно просто перехватыть ошибку, если она возникла при сборке
//и автоматически откладывать процедуру



export default function chips(scheme, args) {

    return {

        //куда распокавать получившийся поток
        //target: scheme,
        //также можно не указывать, если таргет текущий
        //и возвращать сразу функцию конструктора

        //описание самого потока
        constructor: function (cb) {

            cb();

            return function (event) {

                if(event.type === "clear") {
                    cb( { type: "delete", data: [] } );
                }

                else if(event.type === "cancel") {

                }

            }

        }

    }

}


/**
 * type === "some"
 */

/**
 * получить возможность выстраивать структуру заданного вида, вокруг существующего объекта
 * возможность клонировать новые scheme путем наполнения конструктора
 * сущесвтующий конструктор доплняется новыми схемами которые восстанавливаются через build функцию
 */

export default function (scheme, args) {





}

/**
 * Поиск элемента
 * 1. Поиск элемента в контейнере по сигнатуре
 * 2. Если элемент не найден, то выполнить поиск в кеше по сигнатуре
 * 3. Если элемент не найден, то построить новый элемент
 *
 * Идентификация ситуации с новой зависимостью
 * 1. Поиск элемента не дал результатов
 * 2. Попытка создать новый элемент
 * 3. Список добавляет временный middleware, который оповестит систему об окончании загрузки
 * (команда, которая не может быть выполнена, откладывается до следующего события)
 */


/**
 * Спискок спамит сообщениями вида reinit (elems<Type>[]), add (elems<Type>[]), del (elems<Type>[])
 * трансформируя их из reinit ({signature}[])
 */


/**
 * контроллер списка
 * @param scheme
 * @param args
 */
export default function list({scheme, stream}) {

    //коллекция компонентов
    scheme.constructor = [];
    //управление элементами
    scheme.item = stream.reducer( ... {} );

}

export default function chips({scheme, stream}) {

    //stream => stream to list
    list({scheme, stream});
    scheme.constructor.push();

}

/**
 * целостность связей в кешируемых объектах не должна будет нарушиться, так как каждая
 * сущность цепляется к observable зависимсоти своего уровня и при частичной замене все
 * подписчики получают оповещение о необходимости пересборки
 */
















